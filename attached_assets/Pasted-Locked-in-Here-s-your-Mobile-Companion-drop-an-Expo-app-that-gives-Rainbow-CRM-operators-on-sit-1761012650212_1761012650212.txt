Locked in. Here’s your **Mobile Companion** drop—an Expo app that gives Rainbow CRM operators on-site superpowers: offline event checklists, quick proof links, push notifications, and cached assets.

# 🧩 Payload 10.8 — Mobile Companion (React Native / Expo)

## 0) What you get

* Expo app (iOS/Android) using **Expo Router**, **Supabase** auth, **SQLite** offline cache.
* **Event List + Checklist**, **Project Assets**, **Proof Links** (QR open), **Notifications**.
* Sync strategy: optimistic updates → queued in SQLite → background sync to Supabase.

---

## 1) Project init

```bash
npx create-expo-app rainbow-mobile --template
cd rainbow-mobile
npm i @supabase/supabase-js @tanstack/react-query expo-router expo-secure-store expo-notifications expo-sqlite expo-linking
```

Enable Router:

* add `"experimental": { "typedRoutes": true }` to `app.json`
* create `app/` directory (Expo Router convention)

**app.json**

```json
{
  "expo": {
    "name": "Rainbow Mobile",
    "slug": "rainbow-mobile",
    "scheme": "rainbow",
    "ios": { "supportsTablet": true },
    "android": { "adaptiveIcon": { "foregroundImage": "./assets/adaptive-icon.png" } },
    "plugins": ["expo-router", "expo-notifications"],
    "extra": {
      "supabaseUrl": "https://YOUR-SUPABASE.supabase.co",
      "supabaseAnon": "SUPABASE_ANON_KEY",
      "apiBase": "https://your-rainbow-server.com"
    }
  }
}
```

---

## 2) Core utilities

**lib/supabase.ts**

```ts
import 'react-native-url-polyfill/auto';
import { createClient } from '@supabase/supabase-js';
import Constants from 'expo-constants';
import * as SecureStore from 'expo-secure-store';

const { supabaseUrl, supabaseAnon } = Constants.expoConfig!.extra as any;

export const supabase = createClient(supabaseUrl, supabaseAnon, {
  auth: {
    storage: {
      getItem: SecureStore.getItemAsync,
      setItem: SecureStore.setItemAsync,
      removeItem: SecureStore.deleteItemAsync
    },
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: false
  }
});
```

**lib/db.ts (SQLite offline cache)**

```ts
import * as SQLite from 'expo-sqlite';
export const db = SQLite.openDatabaseSync('rainbow.db');

export function initDB() {
  db.execSync(`
    PRAGMA journal_mode = WAL;
    CREATE TABLE IF NOT EXISTS kv (k TEXT PRIMARY KEY, v TEXT);
    CREATE TABLE IF NOT EXISTS pending (id INTEGER PRIMARY KEY AUTOINCREMENT, kind TEXT, payload TEXT);
    CREATE TABLE IF NOT EXISTS events (
      id TEXT PRIMARY KEY, title TEXT, event_date TEXT, location TEXT, stage TEXT, updated_at TEXT
    );
    CREATE TABLE IF NOT EXISTS checklists (
      id TEXT PRIMARY KEY, event_id TEXT, label TEXT, done INTEGER DEFAULT 0
    );
  `);
}
```

**lib/offline.ts**

```ts
import Constants from 'expo-constants';
import { db } from './db';

const API = (Constants.expoConfig!.extra as any).apiBase;

export async function queueAction(kind: string, payload: any) {
  db.runSync('INSERT INTO pending (kind, payload) VALUES (?,?)', [kind, JSON.stringify(payload)]);
}

export async function flushQueue(token?: string) {
  const rows = db.getAllSync<{id:number,kind:string,payload:string}>('SELECT * FROM pending');
  for (const r of rows) {
    try {
      const res = await fetch(`${API}/api/mobile/${r.kind}`, {
        method: 'POST',
        headers: { 'Content-Type':'application/json', ...(token?{Authorization:`Bearer ${token}`}:{}) },
        body: r.payload
      });
      if (res.ok) db.runSync('DELETE FROM pending WHERE id=?', [r.id]);
    } catch {}
  }
}
```

---

## 3) App shell (Expo Router)

**app/_layout.tsx**

```tsx
import { Stack } from 'expo-router';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useEffect } from 'react';
import { initDB } from '../lib/db';
const qc = new QueryClient();

export default function Layout() {
  useEffect(() => { initDB(); }, []);
  return (
    <QueryClientProvider client={qc}>
      <Stack screenOptions={{ headerStyle:{backgroundColor:'#0b0b0d'}, headerTintColor:'#fff' }}>
        <Stack.Screen name="index" options={{ title:'Rainbow' }}/>
        <Stack.Screen name="events/index" options={{ title:'Events' }}/>
        <Stack.Screen name="events/[id]" options={{ title:'Event' }}/>
        <Stack.Screen name="assets/[projectId]" options={{ title:'Assets' }}/>
        <Stack.Screen name="proof/[token]" options={{ title:'Proof' }}/>
      </Stack>
    </QueryClientProvider>
  );
}
```

**app/index.tsx** — simple home

```tsx
import { Link } from 'expo-router';
import { View, Text } from 'react-native';

export default function Home() {
  return (
    <View style={{ flex:1, backgroundColor:'#0b0b0d', padding:16 }}>
      <Text style={{ color:'#ff6fae', fontSize:20, marginBottom:12 }}>Rainbow CRM — Mobile</Text>
      <Link href="/events">Open Events</Link>
    </View>
  );
}
```

---

## 4) Events list + offline cache

**app/events/index.tsx**

```tsx
import { useEffect, useState } from 'react';
import { View, Text, FlatList, RefreshControl, TouchableOpacity } from 'react-native';
import { supabase } from '../../lib/supabase';
import { db } from '../../lib/db';
import { useRouter } from 'expo-router';

type EventRow = { id:string; title:string; event_date:string|null; location:string|null; stage:string|null };

export default function Events() {
  const [rows, setRows] = useState<EventRow[]>([]);
  const [loading, setLoading] = useState(false);
  const router = useRouter();

  async function loadOnline() {
    setLoading(true);
    const { data, error } = await supabase.from('events').select('id,title,event_date,location,stage').order('event_date');
    if (!error && data) {
      db.runSync('DELETE FROM events');
      for (const e of data) db.runSync(
        'INSERT OR REPLACE INTO events (id,title,event_date,location,stage,updated_at) VALUES (?,?,?,?,?,datetime("now"))',
        [e.id, e.title, e.event_date, e.location, e.stage]
      );
    }
    setLoading(false);
    loadOffline();
  }
  function loadOffline() {
    const local = db.getAllSync<EventRow>('SELECT * FROM events ORDER BY event_date');
    setRows(local);
  }

  useEffect(() => { loadOffline(); loadOnline(); }, []);

  return (
    <View style={{ flex:1, backgroundColor:'#0b0b0d', padding:16 }}>
      <Text style={{ color:'#fff', fontSize:18, marginBottom:8 }}>Upcoming Events</Text>
      <FlatList
        data={rows}
        keyExtractor={i=>i.id}
        refreshControl={<RefreshControl refreshing={loading} onRefresh={loadOnline} tintColor="#fff" />}
        renderItem={({item})=>(
          <TouchableOpacity onPress={()=>router.push(`/events/${item.id}`)}
            style={{ backgroundColor:'rgba(255,255,255,0.06)', padding:12, borderRadius:14, marginBottom:10 }}>
            <Text style={{ color:'#fff', fontWeight:'600' }}>{item.title}</Text>
            <Text style={{ color:'#aaa', fontSize:12 }}>{item.event_date || 'TBD'} • {item.location || ''}</Text>
          </TouchableOpacity>
        )}
      />
    </View>
  );
}
```

---

## 5) Event detail + checklist (offline-first)

**app/events/[id].tsx**

```tsx
import { useLocalSearchParams } from 'expo-router';
import { View, Text, FlatList, Switch } from 'react-native';
import { db } from '../../lib/db';
import { useEffect, useState } from 'react';
import { queueAction, flushQueue } from '../../lib/offline';
import * as Network from 'expo-network';

export default function EventDetail() {
  const { id } = useLocalSearchParams<{id:string}>();
  const [event, setEvent] = useState<any>(null);
  const [items, setItems] = useState<any[]>([]);

  function load() {
    const e = db.getFirstSync('SELECT * FROM events WHERE id=?', [id]);
    setEvent(e);
    const list = db.getAllSync('SELECT * FROM checklists WHERE event_id=?', [id]);
    setItems(list);
  }
  useEffect(()=>{ load(); }, [id]);

  function toggle(item:any, val:boolean) {
    // optimistic local write
    db.runSync('UPDATE checklists SET done=? WHERE id=?', [val?1:0, item.id]);
    setItems(prev => prev.map(p => p.id===item.id ? {...p, done: val?1:0} : p));
    // queue for server
    queueAction('checklist_toggle', { id: item.id, done: val });
  }

  useEffect(()=>{ (async ()=>{
    const state = await Network.getNetworkStateAsync();
    if (state.isConnected) await flushQueue();
  })(); }, [items]);

  return (
    <View style={{ flex:1, backgroundColor:'#0b0b0d', padding:16 }}>
      <Text style={{ color:'#ff6fae', fontSize:16 }}>{event?.title}</Text>
      <Text style={{ color:'#aaa', fontSize:12, marginBottom:12 }}>{event?.event_date ?? 'TBD'} • {event?.location ?? ''}</Text>
      <Text style={{ color:'#fff', marginBottom:8 }}>Checklist</Text>
      <FlatList data={items} keyExtractor={i=>i.id} renderItem={({item})=>(
        <View style={{ flexDirection:'row', justifyContent:'space-between', paddingVertical:10, borderBottomColor:'rgba(255,255,255,0.06)', borderBottomWidth:1 }}>
          <Text style={{ color:'#ddd' }}>{item.label}</Text>
          <Switch value={!!item.done} onValueChange={(v)=>toggle(item,v)} />
        </View>
      )}/>
    </View>
  );
}
```

**Server hook (Rainbow server)**

```ts
// routes/mobile.ts
router.post('/mobile/checklist_toggle', requireAuth, async (req,res)=>{
  const { id, done } = req.body;
  const { error } = await supabase.from('checklists').update({ done: done?1:0 }).eq('id', id).eq('owner_id', req.user.id);
  if (error) return res.status(400).json({ error });
  res.json({ ok:true });
});
```

---

## 6) Assets viewer

**app/assets/[projectId].tsx**

```tsx
import { useLocalSearchParams } from 'expo-router';
import { View, Image, FlatList, Text } from 'react-native';
import { supabase } from '../../lib/supabase';
import { useEffect, useState } from 'react';

export default function Assets() {
  const { projectId } = useLocalSearchParams<{projectId:string}>();
  const [assets, setAssets] = useState<any[]>([]);
  useEffect(()=>{ (async()=>{
    const { data } = await supabase.from('assets').select('*').eq('project_id', projectId).order('created_at', { ascending:false });
    setAssets(data || []);
  })(); }, [projectId]);

  return (
    <View style={{ flex:1, backgroundColor:'#0b0b0d', padding:10 }}>
      <FlatList numColumns={2} columnWrapperStyle={{ gap:10 }} contentContainerStyle={{ gap:10 }}
        data={assets} keyExtractor={a=>a.id} renderItem={({item})=>(
        <View style={{ backgroundColor:'rgba(255,255,255,0.06)', borderRadius:12, padding:6, flex:1 }}>
          <Image source={{ uri:item.thumbnail_url || item.file_url }} style={{ width:'100%', height:150, borderRadius:8 }} />
          <Text numberOfLines={1} style={{ color:'#aaa', fontSize:12, marginTop:6 }}>{item.file_name}</Text>
        </View>
      )}/>
    </View>
  );
}
```

---

## 7) Proof links (deep link & QR)

* Mobile can open `rainbow://proof/<token>` deep links from QR codes at events.
* Add a simple proof viewer that loads the public proof (read-only approval if you want).

**app/proof/[token].tsx**

```tsx
import { useLocalSearchParams } from 'expo-router';
import { supabase } from '../../lib/supabase';
import { useEffect, useState } from 'react';
import { View, Image, Text, Button } from 'react-native';

export default function Proof() {
  const { token } = useLocalSearchParams<{token:string}>();
  const [p, setP] = useState<any>(null);
  useEffect(()=>{ (async()=>{
    const { data } = await supabase.from('proofs').select('*, proof_comments(*)').eq('token', token).single();
    setP(data);
  })(); }, [token]);
  if (!p) return null;

  async function approve(status:'approved'|'changes_requested') {
    await fetch(`${(expo as any).Constants.expoConfig.extra.apiBase}/api/proofs/public/${token}/status`, {
      method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ status })
    });
    alert('Recorded!');
  }

  return (
    <View style={{ flex:1, backgroundColor:'#0b0b0d', padding:16 }}>
      <Image source={{ uri:p.image_url }} style={{ width:'100%', height:320, borderRadius:12, marginBottom:12 }}/>
      <Text style={{ color:'#fff', fontWeight:'600', marginBottom:6 }}>{p.title}</Text>
      <View style={{ flexDirection:'row', gap:12 }}>
        <Button title="Approve" onPress={()=>approve('approved')} />
        <Button title="Request Changes" onPress={()=>approve('changes_requested')} />
      </View>
    </View>
  );
}
```

---

## 8) Push notifications (proof status / reminders)

**Setup**

```bash
npx expo install expo-notifications
```

**lib/notifications.ts**

```ts
import * as Notifications from 'expo-notifications';
import * as Device from 'expo-device';

export async function registerForPush() {
  if (!Device.isDevice) return null;
  const { status: existingStatus } = await Notifications.getPermissionsAsync();
  let finalStatus = existingStatus;
  if (existingStatus !== 'granted') {
    const { status } = await Notifications.requestPermissionsAsync();
    finalStatus = status;
  }
  if (finalStatus !== 'granted') return null;
  const token = (await Notifications.getExpoPushTokenAsync()).data;
  return token;
}
```

**On login/startup**, call `registerForPush()`, POST token to your server → store in `profiles.push_token`. Your server can then **notify** when:

* a proof is approved/changes requested,
* a mockup job completes (webhook → send push).

Server snippet:

```ts
// services/push.ts
async function sendPush(expoToken: string, title:string, body:string) {
  await fetch('https://exp.host/--/api/v2/push/send', {
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify({ to: expoToken, title, body })
  });
}
```

---

## 9) Sync policy (the boring-but-important part)

* **Reads**: Always show SQLite cache immediately, then refresh from Supabase.
* **Writes**: Queue to `pending` table, try immediate POST; if offline, leave queued. Background flush on:

  * app focus,
  * network reconnect,
  * pull-to-refresh.
* **Conflicts**: “Last-write-wins” for checklists; for complex entities (notes), add `updated_at` and reject stale writes server-side.

---

## 🔐 Security notes

* Use Supabase RLS (already set in web app).
* Mobile only stores non-sensitive data in SQLite; tokens live in **SecureStore**.
* Block public asset URLs if necessary; serve signed URLs for non-public deliverables.

---

## ✅ Success criteria

* Events list renders from cache in airplane mode; refresh replaces cache when online.
* Checklist toggles work offline and sync later.
* Assets grid shows project thumbnails.
* Proof deep links work; on-site approvals possible.
* Push notifications received for key events.

---

## ⏭ Next step hooks

When you’re ready, we can:

* Add **on-device camera** to attach venue photos to an event.
* Add **QR scanner** to scan a proof token or project link instantly.
* Add **operator timeline** (clock-in/out, notes) with geo-fenced entries.

Want me to ship a **minimal repo layout** (folders + ready files) you can paste into Replit/GitHub, or jump straight to **Monetization Scaffold (Mirror Coins Buy modal + Square sandbox)**?
